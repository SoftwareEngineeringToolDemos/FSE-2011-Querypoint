Thank you for reviewing our paper on 'lastChange'. We respond to the questions raised by the reviewers and then request that the first reviewer reconsider part of their analysis.

1) The first reviewer asked:

Q: "The paper presents the work as a general debugging approach. ... How closely similar could it be possible to support this idea for a compiled language?"

A: Section 3 of our paper presents a general algorithm and we have implemented this technique for Java as shown in this technical report: http://infoscience.epfl.ch/record/164417.

2) The second reviewer asked a few questions about our user study, we summarized them in 3 main questions:

Q: Who were the developers?

A: The developers were all skilled developers with several years of experience in debugging complex programs and familiar with Firebug. They knew the concept of data dependency, however our prototype does not require users to know this concept. We recruited them by asking for volunteers from among people in our department who we knew wrote JavaScript.

Q: How the user study is conducted?

A: The instructions of user study and programs code were provided on the Web site we listed in footnote 4, http://ltiwww.epfl.ch/~mirghase/lastchange-userstudy .

Q: What counted as a 'step' in Figure 12?

A: We should have explained that a step in Figure 12 means a button push, either single stepping the debugger or running a lastChange query.

3) We are very surprised at the claim of reviewer #1 that we don't build on top of existing debug technology. Section 4 of our paper details how we built lastChange on top of the Firebug debugger. Perhaps we should have been clearer: by "breakpoint technology" we mean all the different ways debuggers pause execution when a special event occurs. It includes line step, function enter/exit, variable/property access/change (watchpoint), error/exception, conditional breakpionts, etc. Our ability to build upon existing debugger technology is essential to the practicality of our approach.

Reviewer #1 points to a combination of watchpoints and the 'drop in frame' feature in Eclipse. We do not believe the claim of the first reviewer that "a developer can manually perform a lastChange query in relatively few steps". In fact our user study, as small and limited as it may be, provides direct evidence against this claim. Watchpoints trigger on data value changes; 'Drop in frame' allows for shorter re-execution cycles like the local replay we explained in section 4.5. The fundamental problem with these techniques is that they only work in the 'forward' direction. If we land on a watchpoint after a 'drop in frame' operation, then is this the last change or just one of a hundred changes? This fundamental problem is why papers cited as our references 4, 5, 6, 8, 11, 12, 13, and 15 exist: developers want to go backwards. That is why we called our paper 'lastChange'. As cited in section 8, our approach is superior to even reverse watchpoints, a technology created to go beyond normal watchpoints.



--------------------------------------------------------------------------------
Removed
--------------------------------------------------------------------------------
Moreover our approach can be applied recursively, to obtain the lastChange to a value found on a lastChange.

Again we thank the reviewers. We believe small changes to the text based on this feedback would clarify and improve the paper.
